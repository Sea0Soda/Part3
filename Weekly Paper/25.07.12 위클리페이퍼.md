# Weekly Paper16

## 주제 1: 세션 기반 인증 vs 토큰 기반 인증

### 세션 기반 인증 (Session-based Authentication)

#### 작동 원리

```
1. 사용자 로그인 → 서버에서 세션 생성
2. 세션 ID를 쿠키로 클라이언트에 전송
3. 이후 요청 시 쿠키의 세션 ID로 인증
4. 서버에서 세션 저장소를 통해 사용자 정보 확인
```

<details>
<Summary>세션,쿠키?</Summary>

### 세션 (Session)

**정의:** 서버에서 사용자의 로그인 상태와 관련 정보를 저장하는 임시 데이터 공간

**기술적 설명:**

- 사용자가 로그인하면 서버에서 고유한 세션 ID 생성
- 세션 ID와 연결된 사용자 정보를 서버 메모리나 DB에 저장
- 브라우저는 세션 ID만 쿠키로 보관

---

### 쿠키 (Cookie)

**정의:** 웹사이트가 사용자의 브라우저에 저장하는 작은 데이터 파일

**기술적 설명:**

- 브라우저가 자동으로 관리 (저장, 전송, 삭제)
- 도메인별로 분리 저장 (A사이트 쿠키는 B사이트에서 접근 불가)
- 만료 시간 설정 가능

---

</details>

#### 장점

- **서버 완전 제어**: 세션 무효화가 즉시 가능
- **보안성 높음**: 중요 정보가 서버에만 저장
- **구현 단순**: 전통적인 웹 개발 방식
- **자동 만료**: 브라우저 종료 시 자동 로그아웃

#### 단점

- **확장성 문제**: 서버 간 세션 공유 복잡
- **메모리 사용**: 세션 저장소 필요 (Redis, DB)
- **CORS 제약**: 다른 도메인 간 쿠키 공유 어려움
- **모바일 앱 제약**: 쿠키 처리 복잡

#### 실제 구현 특징

- 서버 메모리나 Redis 같은 세션 저장소 필요
- 쿠키에 세션 ID만 저장하고 실제 데이터는 서버에 보관
- 로그인 시 서버에서 세션 생성, 로그아웃 시 세션 삭제

---

<details>
<Summary>세션 무효화?, 메모리사용?</Summary>

### 세션 무효화가 즉시 가능한 이유와 장점

**왜 즉시 가능한가?**

- 실제 데이터가 서버에 있기 때문
- 서버에서 세션 데이터를 삭제하면 즉시 로그아웃 처리

**왜 장점인가?**

- **보안 사고 시 즉시 대응**: 계정 해킹 발견 시 해당 세션만 즉시 차단
- **강제 로그아웃 가능**: 관리자가 특정 사용자를 즉시 로그아웃 시킬 수 있음
- **중복 로그인 방지**: 다른 기기에서 로그인 시 기존 세션 무효화
- **정책 변경 즉시 적용**: 권한 변경 등이 바로 반영

---

### 메모리 사용 세션 저장소

**메모리 저장소란?**

- RAM(Random Access Memory)을 말하는 것이 맞음
- 하드디스크가 아닌 컴퓨터의 임시 기억장치에 데이터 저장

**왜 메모리를 사용하나?**

- **속도**: 하드디스크보다 수천 배 빠름
- **임시성**: 세션은 일시적인 데이터라서 영구 저장 불필요

**문제점:**

- **서버 재시작 시 데이터 손실**: 모든 사용자가 강제 로그아웃
- **RAM 용량 제한**: 동시 접속자가 많으면 메모리 부족
- **서버 확장 어려움**: 여러 서버 사용 시 세션 공유 복잡

**해결책:**

- **Redis/Memcached**: 세션 전용 메모리 DB 사용
- **DB 저장**: 하드디스크에 저장 (속도는 느리지만 안정적)

</details>

### 토큰 기반 인증 (Token-based Authentication)

#### 작동 원리

```
1. 사용자 로그인 → 서버에서 JWT 토큰 생성
2. 토큰을 클라이언트에 전송 (localStorage/sessionStorage)
3. 이후 요청 시 Authorization 헤더에 토큰 포함
4. 서버에서 토큰 검증하여 사용자 인증
```

<details>
<Summary>JWT? </Summary>

### JWT (JSON Web Token)

**정의:** JSON 형태의 정보를 안전하게 전송하기 위한 토큰 표준

**구조:**

```
Header.Payload.Signature
xxxxx.yyyyy.zzzzz
```

**각 부분 설명:**

- **Header**: 토큰 타입과 암호화 알고리즘 정보
- **Payload**: 실제 사용자 정보 (사용자 ID, 이메일, 권한 등)
- **Signature**: 토큰이 변조되지 않았음을 증명하는 서명

</details>

#### 장점

- **무상태성(Stateless)**: 서버에 세션 저장 불필요
- **확장성 우수**: 마이크로서비스 환경에 적합
- **크로스 도메인**: CORS 제약 없음
- **모바일 친화적**: 앱에서 사용하기 편리
- **분산 시스템**: 여러 서버 간 토큰 공유 가능

### CORS (Cross-Origin Resource Sharing)

**정의:** 다른 도메인 간의 리소스 공유를 제어하는 보안 정책

#### 단점

- **토큰 크기**: 쿠키보다 용량 큰 경우 있음
- **즉시 무효화 어려움**: 토큰 만료 전까지 유효
- **XSS 취약성**: localStorage 저장 시 보안 위험
- **토큰 관리**: Refresh Token 등 복잡한 관리 필요

#### 실제 구현 특징

- JWT(JSON Web Token) 형태로 사용자 정보를 암호화해서 토큰에 포함
- 토큰 자체에 만료 시간, 사용자 ID 등의 정보 포함
- 서버는 토큰의 유효성만 검증하면 되므로 별도 저장소 불필요

---

### 세션 vs 토큰 비교표

| 구분            | 세션 기반        | 토큰 기반          |
| --------------- | ---------------- | ------------------ |
| **저장 위치**   | 서버 (메모리/DB) | 클라이언트         |
| **확장성**      | 어려움           | 쉬움               |
| **보안성**      | 높음             | 중간 (관리에 따라) |
| **즉시 무효화** | 가능             | 어려움             |
| **CORS**        | 제약 있음        | 제약 없음          |
| **모바일 지원** | 복잡             | 쉬움               |
| **서버 부하**   | 높음             | 낮음               |

---

## 2. 구글 소셜 로그인 OAuth 2.0 플로우

### 간단한 4단계 플로우

```
 User →  Frontend →  Backend →  Google → 완료!
```

### 핵심 4단계

#### 1️ 사용자가 "구글 로그인" 클릭

- **User → Frontend**: "구글로 로그인" 버튼 클릭
- **Frontend**: 구글 로그인 페이지로 이동시킴

#### 2️ 구글에서 로그인하고 코드 받기

- **User → Google**: 구글 아이디/비밀번호로 로그인
- **Google → Frontend**: "Authorization Code" 발급해서 돌려보냄

#### 3️ 백엔드가 코드를 토큰으로 교환

- **Frontend → Backend**: "Authorization Code" 전달
- **Backend → Google**: 코드를 "Access Token"으로 교환 요청
- **Google → Backend**: 사용자 정보가 담긴 토큰 전달

#### 4️ 로그인 완료

- **Backend**: 사용자 정보로 자체 JWT 토큰 생성
- **Backend → Frontend**: JWT 토큰 전달
- **Frontend**: 토큰 저장하고 로그인 완료 처리

### 피자 주문으로 이해하기

#### 1️ 피자 주문하기 = "구글 로그인" 클릭

- 고객이 "피자헛으로 주문하기" 버튼 클릭
- 피자헛 주문 페이지로 이동

#### 2️ 피자헛에서 신원 확인 = 구글 로그인

- 피자헛에서 "전화번호와 이름을 알려주세요" 요청
- 고객이 정보 제공하고 "주문 확인 번호" 받음

#### 3️ 주문 확인 번호 전달 = Authorization Code 교환

- 고객이 원래 앱에 "주문 확인 번호" 입력
- 앱이 피자헛에 "이 번호로 고객 정보 주세요" 요청
- 피자헛이 "고객 이름, 전화번호, 주소" 전달

#### 4️ 앱에서 회원가입 완료 = JWT 토큰 생성

- 앱이 받은 정보로 자동 회원가입 처리
- "로그인 완료!" 표시
